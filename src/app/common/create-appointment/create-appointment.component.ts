import { Component, OnInit } from '@angular/core';
import { AuthService } from '../../services/auth.service';
import { ProgramsService } from '../../services/programs.service';
import { User } from '../../models/Users';
import { dA } from '@fullcalendar/core/internal-common';
import { Services } from '../../models/Services';
import {
  FormBuilder,
  FormGroup,
  FormsModule,
  ReactiveFormsModule,
  Validators,
} from '@angular/forms';

import { ActivatedRoute, Router } from '@angular/router';

import { AppointmentService } from '../../services/appointment.service';
import { CommonModule } from '@angular/common';
import { NgbModal } from '@ng-bootstrap/ng-bootstrap';
import { AppointmentPreviewComponent } from './appointment-preview/appointment-preview.component';
import { Appointment, AppointmentStatus } from '../../models/Appointment';
import Swal from 'sweetalert2';
import { Survey } from '../../models/Survey';
import { SurveyComponent } from '../../user/survey/survey.component';
import { SurveyService } from '../../services/survey.service';
import { NotificationService } from '../../services/notification.service';
import { Notification, NotificationType } from '../../models/Notification';
import { user } from '@angular/fire/auth';

@Component({
  selector: 'app-create-appointment',
  standalone: true,
  imports: [ReactiveFormsModule, FormsModule, CommonModule],
  templateUrl: './create-appointment.component.html',
  styleUrl: './create-appointment.component.scss',
})
export class CreateAppointmentComponent implements OnInit {
  user$: User | null = null;
  services$: Services[] = [];
  appointmentForm: FormGroup;
  selectedServiceId: string | null = null;

  isGettingSchedules = false;
  timeSlots$ = [
    '08:00 AM – 09:00 AM',
    '09:00 AM – 10:00 AM',
    '10:00 AM – 11:00 AM',
    '11:00 AM – 12:00 PM',
    '12:00 PM – 01:00 PM',
    '01:00 PM – 02:00 PM',
    '02:00 PM – 03:00 PM',
    '03:00 PM – 04:00 PM',
    '04:00 PM – 05:00 PM',
  ];
  hasPendingAppointment = false;
  selectedTimeSlot: string | null = null;
  selectedSlots: string[] = [];
  onSelectTimeSlot(e: string) {
    if (!this.isAvailable(e)) return;
    this.selectedTimeSlot = e;
  }
  constructor(
    private authService: AuthService,
    private programService: ProgramsService,
    private fb: FormBuilder,

    private activatedRoute: ActivatedRoute,
    private modalService: NgbModal,
    private surveyService: SurveyService,
    private notificationService: NotificationService,
    private appointmentService: AppointmentService,
    private router: Router // for navigation after submission
  ) {
    this.appointmentForm = fb.nonNullable.group({
      name: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      contact: ['', Validators.required],
      serviceId: ['', Validators.required],

      date: ['', Validators.required],
    });
  }

  ngOnInit(): void {
    this.activatedRoute.queryParamMap.subscribe((param) => {
      this.selectedServiceId = param.get('id');
      if (this.selectedServiceId) {
        this.appointmentForm.patchValue({ serviceId: this.selectedServiceId });
      }
    });
    this.authService.getCurrentUser().subscribe((data) => {
      this.user$ = data;
      if (data) {
        this.appointmentForm.patchValue({
          name: data.name,
          email: data.email,
        });

        this.appointmentService.hasPendingAppointment(data.id).then((data) => {
          this.hasPendingAppointment = data;
        });
      }
    });

    this.programService.getAll().subscribe((data) => {
      this.services$ = data;
    });
  }

  minDate = new Date().toISOString().split('T')[0]; // disables past dates
  onDateChange(value: string) {
    this.appointmentService.onDateChange(value).then((data) => {
      this.selectedSlots = data;

      if (
        this.selectedTimeSlot !== null &&
        this.selectedSlots.includes(this.selectedTimeSlot)
      ) {
        this.selectedTimeSlot = null;
      }
    });
  }
  isAvailable(time: string): boolean {
    // available if NOT already booked
    return !this.selectedSlots.includes(time);
  }
  trackByIndex(index: number): number {
    return index;
  }

  submit() {
    if (this.appointmentForm.invalid) {
      Swal.fire({
        icon: 'error',
        title: 'Invalid Form',
        text: 'Please complete all required fields before submitting your appointment.',
        confirmButtonColor: '#d33',
      });
      return;
    }

    if (this.selectedTimeSlot === null) {
      Swal.fire({
        icon: 'warning',
        title: 'No Time Selected',
        text: 'Please choose a time slot before submitting your appointment.',
        confirmButtonColor: '#3085d6',
      });
      return;
    }
    const form = this.appointmentForm.value;
    const appointment: Appointment = {
      id: '', // to be generated by backend
      uid: this.user$?.id || '',

      personalInformation: {
        name: form.name,
        email: form.email,
        contact: form.contact,
      },
      serviceInformation: {
        id:
          this.services$.find((s) => s.id === form.serviceId)?.id ||
          form.serviceId,
        name:
          this.services$.find((s) => s.id === form.serviceId)?.title ||
          'Unknown Service',
      },
      date: form.date,
      time: this.selectedTimeSlot,
      location: 'Sitio Agsuli, Sto. Nino, Sablayan, Occidental Mindoro',
      status: AppointmentStatus.PENDING,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const modalRef = this.modalService.open(AppointmentPreviewComponent);
    modalRef.componentInstance.appointment = appointment;
    modalRef.result.then(async (data) => {
      if (data === true) {
        await this.createNotifition(appointment);
        this.openSurvey();
      }
    });
  }

  async createNotifition(appointment: Appointment) {
    const userNotification: Notification = {
      id: '',
      type: NotificationType.APPOINTMENT,
      title: 'Appointment submitted',
      body: `Your appointment for ${appointment.serviceInformation.name} on ${appointment.date} at ${appointment.time} has been successfully submitted.`,
      recievers: [this.user$?.id ?? ''],
      seen: [],
      returnUrl: `/landing-page/appointments?id=${this.user$?.id}`,
      createdAt: new Date(),
    };
    const adminNotification: Notification = {
      id: '',
      type: NotificationType.APPOINTMENT,
      title: 'New Appointment Submitted',
      body: `A new appointment has been submitted and is awaiting review.`,
      recievers: ['admin'], // or an array of admin UIDs/roles
      seen: [],
      returnUrl: '/administration/main/appointments?status=PENDING',
      createdAt: new Date(),
    };
    await this.notificationService.createCustomNotification(
      userNotification,
      adminNotification
    );
  }

  openSurvey() {
    const modalRef = this.modalService.open(SurveyComponent, { size: 'lg' });
    modalRef.result
      .then((result: Survey | any) => {
        if (result) {
          result.uid = this.user$?.id;
          result.profile = this.user$?.profile;
          result.name = this.user$?.name;
          this.saveSurvey(result);
        }
      })
      .catch((error) => {
        console.log('Survey modal dismissed:', error);
      });
  }

  saveSurvey(survey: Survey) {
    this.surveyService
      .create(survey)
      .then(() => {
        Swal.fire({
          icon: 'success',
          title: 'Survey Submitted',
          text: 'Thank you for completing the survey!',
          confirmButtonColor: '#3085d6',
        });
      })
      .catch((error) => {
        Swal.fire({
          icon: 'error',
          title: 'Submission Failed',
          text: 'Something went wrong. Please try again later.',
          confirmButtonColor: '#d33',
        });
        console.error('Survey submission error:', error);
      });
  }
}
